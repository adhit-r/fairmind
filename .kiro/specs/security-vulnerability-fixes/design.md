# Security Vulnerability Fixes - Design Document

## Overview

This design document outlines the migration from python-jose to PyJWT to resolve critical security vulnerabilities in the FairMind backend. The migration will eliminate CVE-2024-23342 and PVE-2024-64396 vulnerabilities while maintaining full backward compatibility and improving the overall security posture of the JWT authentication system.

## Architecture

### Current Architecture
```
FastAPI Application
├── python-jose[cryptography] 3.5.0
│   └── ecdsa 0.19.1 (VULNERABLE)
│       ├── CVE-2024-23342 (ECDSA signature malleability)
│       └── PVE-2024-64396 (side-channel attacks)
├── JWT Authentication Routes
├── Token Validation Middleware
└── User Authentication Service
```

### Target Architecture
```
FastAPI Application
├── PyJWT 2.10.1 (SECURE)
│   └── No vulnerable dependencies
├── JWT Authentication Routes (Updated)
├── Token Validation Middleware (Updated)
└── User Authentication Service (Updated)
```

### Migration Strategy
1. **Gradual Replacement**: Replace python-jose imports with PyJWT equivalently
2. **API Compatibility**: Maintain the same JWT token format and validation logic
3. **Dependency Cleanup**: Remove python-jose and its vulnerable ecdsa dependency
4. **Testing**: Comprehensive testing to ensure functionality parity

## Components and Interfaces

### 1. JWT Service Layer

#### Current Implementation (python-jose)
```python
from jose import JWTError, jwt
from jose.constants import ALGORITHMS

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None
```

#### Target Implementation (PyJWT)
```python
import jwt
from jwt.exceptions import InvalidTokenError

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except InvalidTokenError:
        return None
```

### 2. Authentication Configuration

#### JWT Configuration Module
```python
# config/jwt_config.py
import jwt
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from jwt.exceptions import InvalidTokenError, ExpiredSignatureError

class JWTManager:
    def __init__(self, secret_key: str, algorithm: str = "HS256"):
        self.secret_key = secret_key
        self.algorithm = algorithm
    
    def create_token(self, payload: Dict[str, Any], expires_delta: Optional[timedelta] = None) -> str:
        """Create a JWT token with the given payload"""
        to_encode = payload.copy()
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(hours=24)
        
        to_encode.update({"exp": expire, "iat": datetime.utcnow()})
        return jwt.encode(to_encode, self.secret_key, algorithm=self.algorithm)
    
    def verify_token(self, token: str) -> Optional[Dict[str, Any]]:
        """Verify and decode a JWT token"""
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])
            return payload
        except ExpiredSignatureError:
            return None
        except InvalidTokenError:
            return None
    
    def decode_token_unsafe(self, token: str) -> Optional[Dict[str, Any]]:
        """Decode token without verification (for debugging)"""
        try:
            return jwt.decode(token, options={"verify_signature": False})
        except Exception:
            return None
```

### 3. Authentication Routes Update

#### Updated Authentication Endpoints
```python
# api/routes/auth.py
from config.jwt_config import JWTManager
from config.settings import settings

jwt_manager = JWTManager(settings.SECRET_KEY, settings.ALGORITHM)

@router.post("/login")
async def login(user_credentials: UserLogin):
    # Authenticate user logic...
    if authenticated:
        access_token = jwt_manager.create_token(
            payload={"sub": user.email, "user_id": user.id},
            expires_delta=timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        )
        return {"access_token": access_token, "token_type": "bearer"}
    
@router.get("/verify")
async def verify_token(token: str = Depends(oauth2_scheme)):
    payload = jwt_manager.verify_token(token)
    if payload is None:
        raise HTTPException(status_code=401, detail="Invalid token")
    return payload
```

### 4. Middleware Updates

#### JWT Authentication Middleware
```python
# middleware/auth_middleware.py
from config.jwt_config import JWTManager
from fastapi import HTTPException, status

async def jwt_auth_middleware(request: Request, call_next):
    # Extract token from Authorization header
    auth_header = request.headers.get("Authorization")
    if auth_header and auth_header.startswith("Bearer "):
        token = auth_header.split(" ")[1]
        payload = jwt_manager.verify_token(token)
        if payload:
            request.state.user = payload
        else:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid or expired token"
            )
    
    response = await call_next(request)
    return response
```

## Data Models

### JWT Payload Structure
```python
# models/jwt_models.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class JWTPayload(BaseModel):
    sub: str  # Subject (user email)
    user_id: int
    exp: datetime  # Expiration time
    iat: datetime  # Issued at time
    scope: Optional[str] = None  # Token scope/permissions

class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
    expires_in: int  # Seconds until expiration

class TokenVerification(BaseModel):
    valid: bool
    payload: Optional[JWTPayload] = None
    error: Optional[str] = None
```

## Error Handling

### JWT Error Handling Strategy

#### Error Types and Responses
```python
# exceptions/jwt_exceptions.py
from fastapi import HTTPException, status

class JWTException(Exception):
    """Base JWT exception"""
    pass

class TokenExpiredException(JWTException):
    """Token has expired"""
    pass

class InvalidTokenException(JWTException):
    """Token is invalid or malformed"""
    pass

class TokenMissingException(JWTException):
    """Token is missing from request"""
    pass

# Error handlers
def handle_jwt_exceptions(exc: JWTException):
    if isinstance(exc, TokenExpiredException):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired",
            headers={"WWW-Authenticate": "Bearer"},
        )
    elif isinstance(exc, InvalidTokenException):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
            headers={"WWW-Authenticate": "Bearer"},
        )
    elif isinstance(exc, TokenMissingException):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token missing",
            headers={"WWW-Authenticate": "Bearer"},
        )
```

### Graceful Degradation
- **Invalid Tokens**: Return 401 with clear error message
- **Expired Tokens**: Return 401 with expiration details
- **Missing Tokens**: Return 401 with authentication requirement
- **Malformed Tokens**: Log security event and return 401

## Testing Strategy

### 1. Unit Tests
```python
# tests/test_jwt_migration.py
import pytest
from datetime import datetime, timedelta
from config.jwt_config import JWTManager

class TestJWTMigration:
    def setup_method(self):
        self.jwt_manager = JWTManager("test-secret-key")
    
    def test_token_creation(self):
        payload = {"sub": "test@example.com", "user_id": 123}
        token = self.jwt_manager.create_token(payload)
        assert isinstance(token, str)
        assert len(token) > 0
    
    def test_token_verification(self):
        payload = {"sub": "test@example.com", "user_id": 123}
        token = self.jwt_manager.create_token(payload)
        decoded = self.jwt_manager.verify_token(token)
        assert decoded["sub"] == "test@example.com"
        assert decoded["user_id"] == 123
    
    def test_expired_token(self):
        payload = {"sub": "test@example.com"}
        token = self.jwt_manager.create_token(
            payload, 
            expires_delta=timedelta(seconds=-1)  # Already expired
        )
        decoded = self.jwt_manager.verify_token(token)
        assert decoded is None
    
    def test_invalid_token(self):
        decoded = self.jwt_manager.verify_token("invalid.token.here")
        assert decoded is None
```

### 2. Integration Tests
```python
# tests/test_auth_integration.py
import pytest
from fastapi.testclient import TestClient
from api.main import app

client = TestClient(app)

class TestAuthIntegration:
    def test_login_creates_valid_token(self):
        response = client.post("/auth/login", json={
            "email": "test@example.com",
            "password": "testpassword"
        })
        assert response.status_code == 200
        token = response.json()["access_token"]
        
        # Verify token works for protected endpoint
        headers = {"Authorization": f"Bearer {token}"}
        protected_response = client.get("/auth/verify", headers=headers)
        assert protected_response.status_code == 200
    
    def test_invalid_token_rejected(self):
        headers = {"Authorization": "Bearer invalid.token.here"}
        response = client.get("/auth/verify", headers=headers)
        assert response.status_code == 401
```

### 3. Security Tests
```python
# tests/test_security_vulnerabilities.py
import subprocess
import pytest

class TestSecurityVulnerabilities:
    def test_no_vulnerable_dependencies(self):
        """Ensure no vulnerable dependencies are present"""
        result = subprocess.run(
            ["uv", "run", "safety", "check", "--json"],
            capture_output=True,
            text=True,
            cwd="apps/backend"
        )
        # Should have no vulnerabilities
        assert "vulnerabilities" not in result.stdout.lower()
    
    def test_ecdsa_not_imported(self):
        """Ensure ecdsa library is not imported anywhere"""
        result = subprocess.run(
            ["grep", "-r", "import ecdsa", "api/"],
            capture_output=True,
            text=True
        )
        assert result.returncode != 0  # No matches found
```

## Migration Plan

### Phase 1: Preparation
1. **Dependency Analysis**: Identify all python-jose usage
2. **Test Coverage**: Ensure comprehensive JWT test coverage
3. **Backup Strategy**: Create rollback plan

### Phase 2: Implementation
1. **Add PyJWT**: Update dependencies to include PyJWT
2. **Create JWT Manager**: Implement new JWT management class
3. **Update Routes**: Migrate authentication routes
4. **Update Middleware**: Migrate JWT middleware

### Phase 3: Testing & Validation
1. **Unit Tests**: Run comprehensive unit tests
2. **Integration Tests**: Verify end-to-end functionality
3. **Security Audit**: Confirm vulnerabilities are resolved
4. **Performance Testing**: Ensure no performance regression

### Phase 4: Deployment
1. **Remove python-jose**: Clean up old dependencies
2. **Update Documentation**: Document the migration
3. **Monitor**: Watch for any issues post-deployment

## Security Considerations

### 1. Token Security
- **Algorithm Consistency**: Maintain HS256 algorithm
- **Secret Key Management**: Use same secret key for compatibility
- **Token Expiration**: Maintain existing expiration logic

### 2. Vulnerability Mitigation
- **CVE-2024-23342**: Eliminated by removing ecdsa dependency
- **PVE-2024-64396**: Eliminated by removing ecdsa dependency
- **Future Vulnerabilities**: Automated security scanning in CI/CD

### 3. Backward Compatibility
- **Existing Tokens**: All existing tokens remain valid
- **API Compatibility**: No changes to JWT token format
- **Client Impact**: Zero impact on frontend applications

## Performance Considerations

### PyJWT vs python-jose Performance
- **PyJWT**: Generally faster due to simpler implementation
- **Memory Usage**: Lower memory footprint without ecdsa
- **Startup Time**: Faster application startup
- **Token Operations**: Comparable or better performance

### Monitoring Metrics
- **Token Creation Time**: Monitor JWT creation performance
- **Token Validation Time**: Monitor JWT validation performance
- **Error Rates**: Track JWT-related errors
- **Security Events**: Monitor for security-related JWT events