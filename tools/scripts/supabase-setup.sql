-- Fairmind Database Setup
-- Run this SQL in your Supabase SQL editor

-- Enable necessary extensions
create extension if not exists "uuid-ossp" with schema extensions;
create extension if not exists "pgcrypto" with schema extensions;
create extension if not exists "vector" with schema extensions;

-- Create custom types if they don't exist
do $$
begin
  if not exists (select 1 from pg_type where typname = 'user_role') then
    create type user_role as enum (
      'user',
      'admin',
      'auditor',
      'developer',
      'analyst',
      'manager',
      'guest'
    );
  end if;
end $$;

-- Create audit_logs table
create table if not exists public.audit_logs (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete set null,
  action text not null,
  resource_type text,
  resource_id text,
  details jsonb,
  ip_address inet,
  user_agent text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable Row Level Security
alter table public.audit_logs enable row level security;

-- Create indexes for better performance
create index if not exists idx_audit_logs_user_id on public.audit_logs (user_id);
create index if not exists idx_audit_logs_created_at on public.audit_logs (created_at);
create index if not exists idx_audit_logs_resource on public.audit_logs (resource_type, resource_id);

-- Create profiles table to extend auth.users
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade primary key,
  username text unique,
  full_name text,
  avatar_url text,
  role user_role not null default 'user'::user_role,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.profiles enable row level security;

-- Create a function to handle new user signups
create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.profiles (id, username, role)
  values (
    new.id, 
    coalesce(new.raw_user_meta_data->>'username', 'user') || '_' || substr(md5(random()::text), 1, 8),
    'user'::user_role
  );
  return new;
end;
$$ language plpgsql security definer;

-- Trigger the function every time a user is created
create or replace trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Create RLS policies for profiles
create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can update own profile."
  on profiles for update
  using ( auth.uid() = id );

-- Create RLS policies for audit_logs
create policy "Enable read access for authenticated users"
  on audit_logs for select
  to authenticated
  using (true);

create policy "Enable insert for authenticated users"
  on audit_logs for insert
  to authenticated
  with check (true);

-- Helper function to list tables
create or replace function public.get_tables()
returns table (table_name text) as $$
begin
  return query 
    select tablename::text 
    from pg_tables 
    where schemaname = 'public';
end;
$$ language plpgsql security definer;

-- Helper function to get current user's role
create or replace function public.get_user_role()
returns user_role as $$
begin
  return (
    select role 
    from public.profiles 
    where id = auth.uid()
  );
end;
$$ language plpgsql security definer;

-- Create a default admin user (password: CHANGE_THIS_PASSWORD - change this after first login)
-- First check if user exists
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM auth.users WHERE email = 'admin@fairmind.app') THEN
    INSERT INTO auth.users (
      id, instance_id, email, encrypted_password, email_confirmed_at,
      raw_app_meta_data, raw_user_meta_data, created_at, updated_at, last_sign_in_at
    ) VALUES (
      '00000000-0000-0000-0000-000000000000',
      '00000000-0000-0000-0000-000000000000',
      'admin@fairmind.app',
      crypt('CHANGE_THIS_PASSWORD', gen_salt('bf')),
      now(),
      '{"provider":"email","providers":["email"]}',
      '{"username":"admin"}',
      now(),
      now(),
      now()
    );
    
    -- Insert into profiles
    INSERT INTO public.profiles (id, username, role)
    VALUES (
      '00000000-0000-0000-0000-000000000000',
      'admin_' || substr(md5(random()::text), 1, 8),
      'admin'::user_role
    )
    ON CONFLICT (id) DO UPDATE 
    SET role = 'admin'::user_role;
  END IF;
END $$;

-- Set admin role for the default admin user
update public.profiles 
set role = 'admin'::user_role 
where id = '00000000-0000-0000-0000-000000000000';

-- Enable realtime for tables
alter publication supabase_realtime add table public.audit_logs;
alter publication supabase_realtime add table public.profiles;

-- ============================================================================
-- ML MODEL VECTOR STORAGE WITH PGVECTOR
-- ============================================================================

-- ML Model embeddings table
CREATE TABLE IF NOT EXISTS ml_model_embeddings (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    model_id VARCHAR(255) NOT NULL,
    model_name VARCHAR(255) NOT NULL,
    embedding vector(1536), -- OpenAI embedding dimension
    model_metadata JSONB NOT NULL,
    bias_characteristics JSONB,
    performance_metrics JSONB,
    ethical_framework JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id)
);

-- Create vector index for similarity search
CREATE INDEX IF NOT EXISTS idx_ml_model_embeddings_vector 
ON ml_model_embeddings 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- Create index for model_id lookups
CREATE INDEX IF NOT EXISTS idx_ml_model_embeddings_model_id 
ON ml_model_embeddings(model_id);

-- Model DNA signatures table with vector support
CREATE TABLE IF NOT EXISTS model_dna_signatures (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    model_id VARCHAR(255) NOT NULL,
    dna_signature VARCHAR(64) NOT NULL,
    dna_embedding vector(1536), -- Vector representation of DNA signature
    parent_models TEXT[],
    child_models TEXT[],
    inheritance_type VARCHAR(50),
    algorithm_family VARCHAR(100),
    bias_inheritance JSONB,
    performance_characteristics JSONB,
    ethical_framework JSONB,
    risk_profile JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id)
);

-- Create vector index for DNA similarity search
CREATE INDEX IF NOT EXISTS idx_model_dna_signatures_vector 
ON model_dna_signatures 
USING ivfflat (dna_embedding vector_cosine_ops)
WITH (lists = 50);

-- Create index for DNA signature lookups
CREATE INDEX IF NOT EXISTS idx_model_dna_signatures_signature 
ON model_dna_signatures(dna_signature);

-- Model lineage vectors table
CREATE TABLE IF NOT EXISTS model_lineage_vectors (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    model_id VARCHAR(255) NOT NULL,
    generation INTEGER NOT NULL,
    lineage_embedding vector(1536), -- Vector representation of lineage path
    parent_embeddings vector(1536)[], -- Array of parent model embeddings
    bias_evolution_vector vector(1536), -- Vector representation of bias evolution
    performance_trend_vector vector(1536), -- Vector representation of performance trend
    risk_evolution_vector vector(1536), -- Vector representation of risk evolution
    lineage_metadata JSONB NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id)
);

-- Create vector index for lineage similarity search
CREATE INDEX IF NOT EXISTS idx_model_lineage_vectors_vector 
ON model_lineage_vectors 
USING ivfflat (lineage_embedding vector_cosine_ops)
WITH (lists = 50);

-- Genetic engineering modifications table with vector support
CREATE TABLE IF NOT EXISTS model_modifications (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    model_id VARCHAR(255) NOT NULL,
    modification_embedding vector(1536), -- Vector representation of modification
    modification_type VARCHAR(50) NOT NULL,
    target_biases TEXT[],
    removal_methods TEXT[],
    safety_level VARCHAR(20),
    performance_impact JSONB,
    bias_reduction JSONB,
    ethical_improvements JSONB,
    validation_results JSONB,
    before_embedding vector(1536), -- Model embedding before modification
    after_embedding vector(1536), -- Model embedding after modification
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id)
);

-- Create vector index for modification similarity search
CREATE INDEX IF NOT EXISTS idx_model_modifications_vector 
ON model_modifications 
USING ivfflat (modification_embedding vector_cosine_ops)
WITH (lists = 50);

-- Historical scenario embeddings table
CREATE TABLE IF NOT EXISTS historical_scenario_embeddings (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    scenario_id VARCHAR(255) NOT NULL,
    scenario_name VARCHAR(255) NOT NULL,
    scenario_embedding vector(1536), -- Vector representation of historical scenario
    time_period VARCHAR(50),
    historical_context JSONB,
    bias_characteristics JSONB,
    ethical_framework JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create vector index for scenario similarity search
CREATE INDEX IF NOT EXISTS idx_historical_scenario_embeddings_vector 
ON historical_scenario_embeddings 
USING ivfflat (scenario_embedding vector_cosine_ops)
WITH (lists = 25);

-- Enable Row Level Security for ML model tables
ALTER TABLE ml_model_embeddings ENABLE ROW LEVEL SECURITY;
ALTER TABLE model_dna_signatures ENABLE ROW LEVEL SECURITY;
ALTER TABLE model_lineage_vectors ENABLE ROW LEVEL SECURITY;
ALTER TABLE model_modifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE historical_scenario_embeddings ENABLE ROW LEVEL SECURITY;

-- RLS Policies for ML model tables
CREATE POLICY "Authenticated users can view ML model embeddings" ON ml_model_embeddings
    FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can insert ML model embeddings" ON ml_model_embeddings
    FOR INSERT WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can update ML model embeddings" ON ml_model_embeddings
    FOR UPDATE USING (auth.role() = 'authenticated');

-- RLS Policies for DNA signatures
CREATE POLICY "Authenticated users can view DNA signatures" ON model_dna_signatures
    FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can insert DNA signatures" ON model_dna_signatures
    FOR INSERT WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can update DNA signatures" ON model_dna_signatures
    FOR UPDATE USING (auth.role() = 'authenticated');

-- RLS Policies for lineage vectors
CREATE POLICY "Authenticated users can view lineage vectors" ON model_lineage_vectors
    FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can insert lineage vectors" ON model_lineage_vectors
    FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- RLS Policies for model modifications
CREATE POLICY "Authenticated users can view model modifications" ON model_modifications
    FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can insert model modifications" ON model_modifications
    FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- RLS Policies for historical scenarios
CREATE POLICY "Authenticated users can view historical scenarios" ON historical_scenario_embeddings
    FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can insert historical scenarios" ON historical_scenario_embeddings
    FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Vector similarity search functions
CREATE OR REPLACE FUNCTION find_similar_models(
    query_embedding vector(1536),
    match_threshold float DEFAULT 0.8,
    match_count int DEFAULT 10
)
RETURNS TABLE (
    model_id VARCHAR(255),
    model_name VARCHAR(255),
    similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        mme.model_id,
        mme.model_name,
        1 - (mme.embedding <=> query_embedding) as similarity
    FROM ml_model_embeddings mme
    WHERE 1 - (mme.embedding <=> query_embedding) > match_threshold
    ORDER BY mme.embedding <=> query_embedding
    LIMIT match_count;
END;
$$;

-- DNA signature similarity search
CREATE OR REPLACE FUNCTION find_similar_dna_signatures(
    query_embedding vector(1536),
    match_threshold float DEFAULT 0.8,
    match_count int DEFAULT 10
)
RETURNS TABLE (
    model_id VARCHAR(255),
    dna_signature VARCHAR(64),
    similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        mds.model_id,
        mds.dna_signature,
        1 - (mds.dna_embedding <=> query_embedding) as similarity
    FROM model_dna_signatures mds
    WHERE 1 - (mds.dna_embedding <=> query_embedding) > match_threshold
    ORDER BY mds.dna_embedding <=> query_embedding
    LIMIT match_count;
END;
$$;

-- Lineage similarity search
CREATE OR REPLACE FUNCTION find_similar_lineages(
    query_embedding vector(1536),
    match_threshold float DEFAULT 0.8,
    match_count int DEFAULT 10
)
RETURNS TABLE (
    model_id VARCHAR(255),
    generation INTEGER,
    similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        mlv.model_id,
        mlv.generation,
        1 - (mlv.lineage_embedding <=> query_embedding) as similarity
    FROM model_lineage_vectors mlv
    WHERE 1 - (mlv.lineage_embedding <=> query_embedding) > match_threshold
    ORDER BY mlv.lineage_embedding <=> query_embedding
    LIMIT match_count;
END;
$$;

-- Historical scenario similarity search
CREATE OR REPLACE FUNCTION find_similar_historical_scenarios(
    query_embedding vector(1536),
    match_threshold float DEFAULT 0.8,
    match_count int DEFAULT 10
)
RETURNS TABLE (
    scenario_id VARCHAR(255),
    scenario_name VARCHAR(255),
    time_period VARCHAR(50),
    similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        hse.scenario_id,
        hse.scenario_name,
        hse.time_period,
        1 - (hse.scenario_embedding <=> query_embedding) as similarity
    FROM historical_scenario_embeddings hse
    WHERE 1 - (hse.scenario_embedding <=> query_embedding) > match_threshold
    ORDER BY hse.scenario_embedding <=> query_embedding
    LIMIT match_count;
END;
$$;

-- Enable realtime for ML model tables
alter publication supabase_realtime add table public.ml_model_embeddings;
alter publication supabase_realtime add table public.model_dna_signatures;
alter publication supabase_realtime add table public.model_lineage_vectors;
alter publication supabase_realtime add table public.model_modifications;
alter publication supabase_realtime add table public.historical_scenario_embeddings;

-- ============================================================================
-- GEOGRAPHIC BIAS ANALYSIS TABLES
-- ============================================================================

-- Main geographic bias analysis table
CREATE TABLE IF NOT EXISTS geographic_bias_analyses (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    model_id VARCHAR(255) NOT NULL,
    source_country VARCHAR(100) NOT NULL,
    target_country VARCHAR(100) NOT NULL,
    bias_detected BOOLEAN NOT NULL,
    bias_score DECIMAL(3,3) NOT NULL CHECK (bias_score >= 0 AND bias_score <= 1),
    performance_drop DECIMAL(5,2) NOT NULL,
    risk_level VARCHAR(20) NOT NULL CHECK (risk_level IN ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')),
    affected_metrics JSONB NOT NULL,
    recommendations JSONB NOT NULL,
    cultural_factors JSONB NOT NULL,
    compliance_issues JSONB NOT NULL,
    model_performance_data JSONB NOT NULL,
    demographic_data JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_by UUID REFERENCES auth.users(id)
);

-- Index for efficient querying
CREATE INDEX IF NOT EXISTS idx_geographic_bias_model_id ON geographic_bias_analyses(model_id);
CREATE INDEX IF NOT EXISTS idx_geographic_bias_countries ON geographic_bias_analyses(source_country, target_country);
CREATE INDEX IF NOT EXISTS idx_geographic_bias_risk_level ON geographic_bias_analyses(risk_level);
CREATE INDEX IF NOT EXISTS idx_geographic_bias_created_at ON geographic_bias_analyses(created_at);

-- Country performance tracking table
CREATE TABLE IF NOT EXISTS country_performance_metrics (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    country_code VARCHAR(10) NOT NULL,
    country_name VARCHAR(100) NOT NULL,
    models_deployed INTEGER DEFAULT 0,
    avg_bias_score DECIMAL(3,3) DEFAULT 0,
    compliance_status VARCHAR(20) DEFAULT 'UNKNOWN' CHECK (compliance_status IN ('COMPLIANT', 'WARNING', 'NON_COMPLIANT', 'UNKNOWN')),
    total_analyses INTEGER DEFAULT 0,
    high_risk_count INTEGER DEFAULT 0,
    last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for country performance
CREATE INDEX IF NOT EXISTS idx_country_performance_code ON country_performance_metrics(country_code);
CREATE INDEX IF NOT EXISTS idx_country_performance_status ON country_performance_metrics(compliance_status);

-- Cultural factors reference table
CREATE TABLE IF NOT EXISTS cultural_factors (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    factor_name VARCHAR(100) NOT NULL,
    factor_category VARCHAR(50) NOT NULL CHECK (factor_category IN ('LANGUAGE', 'ECONOMIC', 'CULTURAL', 'REGULATORY')),
    description TEXT,
    weight DECIMAL(3,3) DEFAULT 0.25 CHECK (weight >= 0 AND weight <= 1),
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Insert default cultural factors
INSERT INTO cultural_factors (factor_name, factor_category, description, weight) VALUES
('Language Differences', 'LANGUAGE', 'Linguistic variations affecting model performance', 0.3),
('Economic Factors', 'ECONOMIC', 'GDP, income levels, economic indicators', 0.25),
('Cultural Norms', 'CULTURAL', 'Social customs, traditions, behavioral patterns', 0.25),
('Regulatory Environment', 'REGULATORY', 'Data protection laws, AI regulations', 0.2)
ON CONFLICT DO NOTHING;

-- Geographic bias alerts table
CREATE TABLE IF NOT EXISTS geographic_bias_alerts (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    analysis_id UUID REFERENCES geographic_bias_analyses(id) ON DELETE CASCADE,
    alert_type VARCHAR(50) NOT NULL CHECK (alert_type IN ('HIGH_BIAS', 'COMPLIANCE_VIOLATION', 'PERFORMANCE_DROP', 'CULTURAL_FACTOR_CHANGE')),
    severity VARCHAR(20) NOT NULL CHECK (severity IN ('LOW', 'MEDIUM', 'HIGH', 'CRITICAL')),
    message TEXT NOT NULL,
    is_resolved BOOLEAN DEFAULT false,
    resolved_at TIMESTAMP WITH TIME ZONE,
    resolved_by UUID REFERENCES auth.users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Index for alerts
CREATE INDEX IF NOT EXISTS idx_geographic_bias_alerts_type ON geographic_bias_alerts(alert_type);
CREATE INDEX IF NOT EXISTS idx_geographic_bias_alerts_severity ON geographic_bias_alerts(severity);
CREATE INDEX IF NOT EXISTS idx_geographic_bias_alerts_resolved ON geographic_bias_alerts(is_resolved);

-- Enable Row Level Security (RLS) for geographic bias tables
ALTER TABLE geographic_bias_analyses ENABLE ROW LEVEL SECURITY;
ALTER TABLE country_performance_metrics ENABLE ROW LEVEL SECURITY;
ALTER TABLE cultural_factors ENABLE ROW LEVEL SECURITY;
ALTER TABLE geographic_bias_alerts ENABLE ROW LEVEL SECURITY;

-- RLS Policies for geographic_bias_analyses
CREATE POLICY "Authenticated users can view geographic bias analyses" ON geographic_bias_analyses
    FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can insert geographic bias analyses" ON geographic_bias_analyses
    FOR INSERT WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can update geographic bias analyses" ON geographic_bias_analyses
    FOR UPDATE USING (auth.role() = 'authenticated');

-- RLS Policies for country_performance_metrics (read-only for all authenticated users)
CREATE POLICY "Authenticated users can view country performance" ON country_performance_metrics
    FOR SELECT USING (auth.role() = 'authenticated');

-- RLS Policies for cultural_factors (read-only for all authenticated users)
CREATE POLICY "Authenticated users can view cultural factors" ON cultural_factors
    FOR SELECT USING (auth.role() = 'authenticated');

-- RLS Policies for geographic_bias_alerts
CREATE POLICY "Authenticated users can view geographic bias alerts" ON geographic_bias_alerts
    FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Authenticated users can insert geographic bias alerts" ON geographic_bias_alerts
    FOR INSERT WITH CHECK (auth.role() = 'authenticated');

-- Create function to update country performance metrics
CREATE OR REPLACE FUNCTION update_country_performance_metrics()
RETURNS TRIGGER AS $$
BEGIN
    -- Update or insert country performance metrics
    INSERT INTO country_performance_metrics (country_code, country_name, models_deployed, avg_bias_score, compliance_status, total_analyses, high_risk_count)
    VALUES (
        NEW.target_country,
        NEW.target_country,
        1,
        NEW.bias_score,
        CASE 
            WHEN NEW.risk_level IN ('HIGH', 'CRITICAL') THEN 'NON_COMPLIANT'
            WHEN NEW.risk_level = 'MEDIUM' THEN 'WARNING'
            ELSE 'COMPLIANT'
        END,
        1,
        CASE WHEN NEW.risk_level IN ('HIGH', 'CRITICAL') THEN 1 ELSE 0 END
    )
    ON CONFLICT (country_code) DO UPDATE SET
        models_deployed = country_performance_metrics.models_deployed + 1,
        avg_bias_score = (country_performance_metrics.avg_bias_score * country_performance_metrics.total_analyses + NEW.bias_score) / (country_performance_metrics.total_analyses + 1),
        compliance_status = CASE 
            WHEN NEW.risk_level IN ('HIGH', 'CRITICAL') THEN 'NON_COMPLIANT'
            WHEN NEW.risk_level = 'MEDIUM' THEN 'WARNING'
            ELSE 'COMPLIANT'
        END,
        total_analyses = country_performance_metrics.total_analyses + 1,
        high_risk_count = country_performance_metrics.high_risk_count + CASE WHEN NEW.risk_level IN ('HIGH', 'CRITICAL') THEN 1 ELSE 0 END,
        last_updated = NOW();
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically update country performance metrics
CREATE TRIGGER trigger_update_country_performance
    AFTER INSERT ON geographic_bias_analyses
    FOR EACH ROW
    EXECUTE FUNCTION update_country_performance_metrics();

-- Create function to generate alerts for high-risk analyses
CREATE OR REPLACE FUNCTION generate_geographic_bias_alerts()
RETURNS TRIGGER AS $$
BEGIN
    -- Generate alert for high bias
    IF NEW.bias_score > 0.5 THEN
        INSERT INTO geographic_bias_alerts (analysis_id, alert_type, severity, message)
        VALUES (
            NEW.id,
            'HIGH_BIAS',
            CASE 
                WHEN NEW.bias_score > 0.7 THEN 'CRITICAL'
                ELSE 'HIGH'
            END,
            'High geographic bias detected: ' || NEW.bias_score || ' for model ' || NEW.model_id || ' from ' || NEW.source_country || ' to ' || NEW.target_country
        );
    END IF;
    
    -- Generate alert for compliance issues
    IF NEW.risk_level IN ('HIGH', 'CRITICAL') THEN
        INSERT INTO geographic_bias_alerts (analysis_id, alert_type, severity, message)
        VALUES (
            NEW.id,
            'COMPLIANCE_VIOLATION',
            NEW.risk_level,
            'Compliance violation detected for model ' || NEW.model_id || ' deployment from ' || NEW.source_country || ' to ' || NEW.target_country
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically generate alerts
CREATE TRIGGER trigger_generate_geographic_bias_alerts
    AFTER INSERT ON geographic_bias_analyses
    FOR EACH ROW
    EXECUTE FUNCTION generate_geographic_bias_alerts();

-- Enable realtime for geographic bias tables
alter publication supabase_realtime add table public.geographic_bias_analyses;
alter publication supabase_realtime add table public.country_performance_metrics;
alter publication supabase_realtime add table public.cultural_factors;
alter publication supabase_realtime add table public.geographic_bias_alerts;