const { Client } = require('pg');
const path = require('path');
const dotenv = require('dotenv');
const fs = require('fs');

// Load environment variables from .env.local
dotenv.config({ path: path.resolve(__dirname, '../../.env.local') });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_SERVICE_ROLE_KEY;
const databaseUrl = process.env.DATABASE_URL;

console.log('=== Clean Supabase Database Setup ===');
console.log(`SUPABASE_URL: ${supabaseUrl}`);
console.log(`DATABASE_URL: ${databaseUrl ? 'Found' : 'Missing'}`);

if (!databaseUrl) {
  console.error('❌ Error: Missing DATABASE_URL in environment variables');
  process.exit(1);
}

async function runSQLFile(client, sqlContent, description) {
  try {
    console.log(`📝 Running ${description}...`);
    await client.query(sqlContent);
    console.log(`✅ ${description} completed successfully`);
  } catch (error) {
    console.error(`❌ Error in ${description}:`, error.message);
    throw error;
  }
}

async function setupSupabase() {
  const client = new Client({
    connectionString: databaseUrl,
    ssl: { 
      rejectUnauthorized: false,
      checkServerIdentity: () => undefined
    }
  });

  try {
    console.log('🔌 Connecting to database...');
    await client.connect();
    console.log('✅ Connected to database');

    // Step 1: Drop existing functions that might conflict
    console.log('🧹 Cleaning up existing functions...');
    const cleanupSQL = `
      DROP FUNCTION IF EXISTS public.get_user_role() CASCADE;
      DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;
      DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
    `;
    await client.query(cleanupSQL);
    console.log('✅ Cleanup completed');

    // Step 2: Create basic schema
    const basicSchemaSQL = `
      -- Enable necessary extensions
      CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA extensions;
      CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA extensions;
      CREATE EXTENSION IF NOT EXISTS "vector" WITH SCHEMA extensions;

      -- Create custom types if they don't exist
      DO $$
      BEGIN
        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
          CREATE TYPE user_role AS ENUM (
            'user',
            'admin',
            'auditor',
            'developer',
            'analyst',
            'manager',
            'guest'
          );
        END IF;
      END $$;

      -- Create profiles table to extend auth.users
      CREATE TABLE IF NOT EXISTS public.profiles (
        id uuid REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
        username text UNIQUE,
        full_name text,
        avatar_url text,
        role user_role NOT NULL DEFAULT 'user'::user_role,
        created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
        updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
      );

      -- Create audit_logs table
      CREATE TABLE IF NOT EXISTS public.audit_logs (
        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        user_id uuid REFERENCES auth.users ON DELETE SET NULL,
        action text NOT NULL,
        resource_type text,
        resource_id text,
        details jsonb,
        ip_address inet,
        user_agent text,
        created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
      );

      -- Enable Row Level Security
      ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
      ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

      -- Create indexes for better performance
      CREATE INDEX IF NOT EXISTS idx_audit_logs_user_id ON public.audit_logs (user_id);
      CREATE INDEX IF NOT EXISTS idx_audit_logs_created_at ON public.audit_logs (created_at);
      CREATE INDEX IF NOT EXISTS idx_audit_logs_resource ON public.audit_logs (resource_type, resource_id);
    `;
    await runSQLFile(client, basicSchemaSQL, 'basic schema creation');

    // Step 3: Create functions
    const functionsSQL = `
      -- Create a function to handle new user signups
      CREATE OR REPLACE FUNCTION public.handle_new_user() 
      RETURNS trigger AS $$
      BEGIN
        INSERT INTO public.profiles (id, username, role)
        VALUES (
          new.id, 
          COALESCE(new.raw_user_meta_data->>'username', 'user') || '_' || substr(md5(random()::text), 1, 8),
          'user'::user_role
        );
        RETURN new;
      END;
      $$ LANGUAGE plpgsql SECURITY DEFINER;

      -- Create helper function to get user role
      CREATE OR REPLACE FUNCTION public.get_user_role()
      RETURNS user_role AS $$
      BEGIN
        RETURN (
          SELECT role 
          FROM public.profiles 
          WHERE id = auth.uid()
        );
      END;
      $$ LANGUAGE plpgsql SECURITY DEFINER;

      -- Trigger the function every time a user is created
      CREATE OR REPLACE TRIGGER on_auth_user_created
        AFTER INSERT ON auth.users
        FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
    `;
    await runSQLFile(client, functionsSQL, 'function creation');

    // Step 4: Create RLS policies
    const policiesSQL = `
      -- Create RLS policies for profiles
      DROP POLICY IF EXISTS "Public profiles are viewable by everyone." ON profiles;
      CREATE POLICY "Public profiles are viewable by everyone."
        ON profiles FOR SELECT
        USING ( true );

      DROP POLICY IF EXISTS "Users can update own profile." ON profiles;
      CREATE POLICY "Users can update own profile."
        ON profiles FOR UPDATE
        USING ( auth.uid() = id );

      -- Create RLS policies for audit_logs
      DROP POLICY IF EXISTS "Enable read access for authenticated users" ON audit_logs;
      CREATE POLICY "Enable read access for authenticated users"
        ON audit_logs FOR SELECT
        TO authenticated
        USING (true);

      DROP POLICY IF EXISTS "Enable insert for authenticated users" ON audit_logs;
      CREATE POLICY "Enable insert for authenticated users"
        ON audit_logs FOR INSERT
        TO authenticated
        WITH CHECK (true);
    `;
    await runSQLFile(client, policiesSQL, 'RLS policies');

    // Step 5: Create organizations and models tables
    const orgModelsSQL = `
      -- Create organizations table
      CREATE TABLE IF NOT EXISTS public.organizations (
        id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        name text NOT NULL,
        domain text UNIQUE,
        created_by uuid NOT NULL,
        created_at timestamp with time zone NOT NULL DEFAULT now(),
        UNIQUE (lower(name))
      );

      -- Create organization members table
      CREATE TABLE IF NOT EXISTS public.organization_members (
        org_id uuid NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,
        user_id uuid NOT NULL,
        role text NOT NULL CHECK (role IN ('owner','admin','member','viewer')),
        status text NOT NULL DEFAULT 'active' CHECK (status IN ('active','invited','disabled')),
        joined_at timestamp with time zone NOT NULL DEFAULT now(),
        PRIMARY KEY (org_id, user_id)
      );

      -- Create AI models table
      CREATE TABLE IF NOT EXISTS public.ai_models (
        id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        name text NOT NULL,
        version text NOT NULL,
        model_type text NOT NULL,
        framework text,
        description text,
        file_path text,
        file_size bigint,
        sha256_hash text,
        metadata jsonb,
        organization_id uuid REFERENCES public.organizations(id) ON DELETE CASCADE,
        created_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
        created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
        updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
      );

      -- Create bias analysis results table
      CREATE TABLE IF NOT EXISTS public.bias_analyses (
        id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        model_id uuid REFERENCES public.ai_models(id) ON DELETE CASCADE,
        dataset_name text,
        analysis_type text NOT NULL,
        results jsonb NOT NULL,
        status text NOT NULL DEFAULT 'completed',
        created_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,
        created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
      );

      -- Enable RLS on new tables
      ALTER TABLE public.organizations ENABLE ROW LEVEL SECURITY;
      ALTER TABLE public.organization_members ENABLE ROW LEVEL SECURITY;
      ALTER TABLE public.ai_models ENABLE ROW LEVEL SECURITY;
      ALTER TABLE public.bias_analyses ENABLE ROW LEVEL SECURITY;

      -- Create indexes
      CREATE INDEX IF NOT EXISTS idx_ai_models_org_id ON public.ai_models (organization_id);
      CREATE INDEX IF NOT EXISTS idx_ai_models_created_by ON public.ai_models (created_by);
      CREATE INDEX IF NOT EXISTS idx_bias_analyses_model_id ON public.bias_analyses (model_id);
      CREATE INDEX IF NOT EXISTS idx_bias_analyses_created_by ON public.bias_analyses (created_by);
    `;
    await runSQLFile(client, orgModelsSQL, 'organizations and models tables');

    // Step 6: Create RLS policies for new tables
    const newPoliciesSQL = `
      -- Organizations policies
      CREATE POLICY IF NOT EXISTS "Users can view organizations they belong to"
        ON public.organizations FOR SELECT
        USING (
          EXISTS (
            SELECT 1 FROM public.organization_members
            WHERE org_id = organizations.id AND user_id = auth.uid()
          )
        );

      -- Organization members policies
      CREATE POLICY IF NOT EXISTS "Users can view members of their organizations"
        ON public.organization_members FOR SELECT
        USING (
          EXISTS (
            SELECT 1 FROM public.organization_members om
            WHERE om.org_id = organization_members.org_id AND om.user_id = auth.uid()
          )
        );

      -- AI models policies
      CREATE POLICY IF NOT EXISTS "Users can view models in their organizations"
        ON public.ai_models FOR SELECT
        USING (
          EXISTS (
            SELECT 1 FROM public.organization_members
            WHERE org_id = ai_models.organization_id AND user_id = auth.uid()
          )
        );

      CREATE POLICY IF NOT EXISTS "Users can create models in their organizations"
        ON public.ai_models FOR INSERT
        WITH CHECK (
          EXISTS (
            SELECT 1 FROM public.organization_members
            WHERE org_id = ai_models.organization_id AND user_id = auth.uid()
            AND role IN ('owner', 'admin', 'member')
          )
        );

      -- Bias analyses policies
      CREATE POLICY IF NOT EXISTS "Users can view bias analyses for models in their organizations"
        ON public.bias_analyses FOR SELECT
        USING (
          EXISTS (
            SELECT 1 FROM public.ai_models am
            JOIN public.organization_members om ON am.organization_id = om.org_id
            WHERE am.id = bias_analyses.model_id AND om.user_id = auth.uid()
          )
        );
    `;
    await runSQLFile(client, newPoliciesSQL, 'RLS policies for new tables');

    console.log('🎉 Database setup completed successfully!');
    console.log('\n📋 Next steps:');
    console.log('1. Test the connection with: node test-supabase-connection.js');
    console.log('2. Set up authentication in your frontend');
    console.log('3. Replace mock data with real database queries');

  } catch (error) {
    console.error('❌ Setup failed:', error);
    throw error;
  } finally {
    await client.end();
  }
}

setupSupabase().catch(console.error);
